/*
 * Copyright 2015-2018 Josh Cummings
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.joshcummings.codeplay.terracotta;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;
import com.joshcummings.codeplay.terracotta.model.Account;
import com.joshcummings.codeplay.terracotta.model.Client;
import com.joshcummings.codeplay.terracotta.service.AccountService;
import com.joshcummings.codeplay.terracotta.service.ClientService;
import com.joshcummings.codeplay.terracotta.testng.HttpSupport;
import com.joshcummings.codeplay.terracotta.testng.TomcatSupport;
import org.apache.http.HttpEntity;
import org.apache.http.client.methods.RequestBuilder;
import org.apache.http.entity.BasicHttpEntity;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;

import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.io.ByteArrayInputStream;
import java.math.BigDecimal;
import java.net.URI;
import java.nio.ByteBuffer;
import java.security.KeyFactory;
import java.security.Signature;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.time.Instant;
import java.util.Base64;
import java.util.UUID;

import static java.nio.charset.StandardCharsets.UTF_8;
import static org.junit.Assert.assertEquals;

/**
 * @author Josh Cummings
 */
public class BankTransferFunctionalTest {
	TomcatSupport tomcat = new TomcatSupport();
	HttpSupport http = new HttpSupport();
	AccountService accountService;
	ClientService clientService;

	Account account = new Account("0", new BigDecimal("25"), 98L, "0");
	Client v1Client = new Client("00", "12341234", secretKey(), Client.Algorithm.v1, URI.create("http://localhost:8081/.well-known/jwks.json"));
	Client v2Client = new Client("01", "43214321", publicKey(), Client.Algorithm.v2, URI.create("http://localhost:8081/.well-known/jwks.json"));

	Gson gson = new Gson();

	@BeforeMethod(alwaysRun=true)
	public void setup() {
		this.tomcat.startContainer();
		this.accountService = this.tomcat.getContext().getBean(AccountService.class);
		this.accountService.addAccount(this.account);
		this.clientService = this.tomcat.getContext().getBean(ClientService.class);
		this.clientService.addClient(this.v1Client);
		this.clientService.addClient(this.v2Client);
	}

	@AfterMethod(alwaysRun=true)
	public void shutdown() {
		this.tomcat.stopContainer();
	}

	@Test
	public void testUnsignedBankTransfer() throws Exception {
		int status = this.http.postForStatus(RequestBuilder.post("/bankTransfer")
				.addParameter("clientId", this.v1Client.getClientId())
				.addParameter("accountNumber", String.valueOf(this.account.getNumber()))
				.addParameter("amount", "92.00"));

		assertEquals(status, 401);
		Account updated = this.accountService.findByAccountNumber(this.account.getNumber().intValue());
		assertEquals(updated.getAmount().intValue(), this.account.getAmount().intValue());
	}

	@Test
	public void testAlteredBankTransfer() throws Exception {
		Mac mac = Mac.getInstance("HMACSHA256");
		mac.init(this.v1Client.getClientSecret());
		mac.update("v1".getBytes(UTF_8)); // algorithm version
		mac.update(this.v1Client.getClientId().getBytes(UTF_8));
		mac.update(String.valueOf(this.account.getNumber()).getBytes(UTF_8));
		mac.update("92.00".getBytes());
		byte[] bytes = mac.doFinal();
		String encoded = Base64.getEncoder().encodeToString(bytes);

		int status = this.http.postForStatus(RequestBuilder.post("/bankTransfer")
				.addParameter("version", "v1")
				.addParameter("clientId", this.v1Client.getClientId())
				.addParameter("accountNumber", String.valueOf(this.account.getNumber()))
				.addParameter("amount", "92000.00") // alter the payload
				.addParameter("signature", encoded));

		assertEquals(401, status);
		Account updated = this.accountService.findByAccountNumber(this.account.getNumber().intValue());
		assertEquals(updated.getAmount().intValue(), this.account.getAmount().intValue());
	}

	@Test
	public void testMisattributedBankTransfer() throws Exception {
		Signature signature = Signature.getInstance("SHA256WITHRSA");
		signature.initSign(privateKey());
		signature.update("v2".getBytes(UTF_8)); // algorithm version
		signature.update(this.v1Client.getClientId().getBytes(UTF_8));
		signature.update(String.valueOf(this.account.getNumber()).getBytes(UTF_8));
		signature.update("92.00".getBytes());
		String encoded = Base64.getEncoder().encodeToString(signature.sign());

		int status = this.http.postForStatus(RequestBuilder.post("/bankTransfer")
				.addParameter("version", "v2")
				.addParameter("clientId", this.v1Client.getClientId()) // someone else's id
				.addParameter("accountNumber", String.valueOf(this.account.getNumber()))
				.addParameter("amount", "92.00")
				.addParameter("signature", encoded));

		assertEquals(401, status);
		Account updated = this.accountService.findByAccountNumber(this.account.getNumber().intValue());
		assertEquals(updated.getAmount().intValue(), this.account.getAmount().intValue());
	}

	@Test
	public void testReplayedBankTransfer() throws Exception {
		String id = UUID.randomUUID().toString();
		Long created = Instant.now().toEpochMilli() / 1000;
		Signature signature = Signature.getInstance("SHA256WITHRSA");
		signature.initSign(privateKey());
		signature.update("v2".getBytes(UTF_8)); // algorithm version
		signature.update(id.getBytes(UTF_8)); // id
		signature.update(String.valueOf(created).getBytes(UTF_8));
		signature.update(this.v2Client.getClientId().getBytes(UTF_8));
		signature.update(String.valueOf(this.account.getNumber()).getBytes(UTF_8));
		signature.update("92.00".getBytes());
		String encoded = Base64.getEncoder().encodeToString(signature.sign());

		int status = this.http.postForStatus(RequestBuilder.post("/bankTransfer")
				.addParameter("version", "v2")
				.addParameter("id", id)
				.addParameter("created", String.valueOf(created))
				.addParameter("clientId", this.v2Client.getClientId())
				.addParameter("accountNumber", String.valueOf(this.account.getNumber()))
				.addParameter("amount", "92.00")
				.addParameter("signature", encoded));

		assertEquals(200, status);

		Account updated = this.accountService.findByAccountNumber(this.account.getNumber().intValue());

		status = this.http.postForStatus(RequestBuilder.post("/bankTransfer")
				.addParameter("version", "v2")
				.addParameter("id", id)
				.addParameter("created", String.valueOf(created))
				.addParameter("kid", "1")
				.addParameter("clientId", this.v2Client.getClientId())
				.addParameter("accountNumber", String.valueOf(this.account.getNumber()))
				.addParameter("amount", "92.00")
				.addParameter("signature", encoded));

		assertEquals(401, status);
		Account again = this.accountService.findByAccountNumber(this.account.getNumber().intValue());
		assertEquals(again.getAmount().intValue(), updated.getAmount().intValue());
	}

	@Test
	public void testEncryptedBankTransfer() throws Exception {
		RequestBuilder builder = RequestBuilder.post("/bankTransfer")
				.setHeader("Content-Type", "application/json");
		JsonObject json = new JsonObject();
		json.add("clientId", new JsonPrimitive(this.v1Client.getClientId()));
		json.add("accountNumber", new JsonPrimitive(this.account.getNumber()));
		json.add("amount", new JsonPrimitive("92.00"));
		byte[] request = this.gson.toJson(json).getBytes(UTF_8);
		addEncrypted(request, builder);

		int status = this.http.postForStatus(builder.setHeader("X-Encryption", "v1"));
		assertEquals(status, 200);
	}

	private void addEncrypted(byte[] plaintext, RequestBuilder builder) throws Exception {
		ByteBuffer buffer = ByteBuffer.allocate(plaintext.length);
		for (byte b : plaintext) {
			buffer.put((byte)(((b + 128) - 13 + 256) % 256 - 128));
		}
		byte[] ciphertext = buffer.array();

		String body = Base64.getEncoder().encodeToString(ciphertext);
		HttpEntity entity = new BasicHttpEntity();
		((BasicHttpEntity) entity).setContent(new ByteArrayInputStream(body.getBytes(UTF_8)));
		builder.setEntity(entity);
	}

	private static SecretKey secretKey() {
		byte[] bytes = Base64.getDecoder().decode("fYJE4bObiVAbhseUTXaRkg==".getBytes(UTF_8));
		return new SecretKeySpec(bytes, "AES");
	}

	private static RSAPublicKey publicKey() {
		try {
			byte[] bytes = Base64.getDecoder().decode("MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtWO9vMYnCtL55JKSAkPLVZ8EzAcpSoNSM42UBdcaoZUks8SYQMYrshQmrcYB6RNcqglJX9EWCeD14y6nt5cTEsW6UAabZD/7Qj1tyJm50KA3UFwDov3n4xwtph5EAbLxw/DiFt6rN3kXwDiuzjuWg9ShmoxeE3LTTLVy/B+WP5YfeXoSOrGHTj/hpexDG5pYUIFPoDb79LzzBbghpQ3Pvwg1lkKAnL1OYLkv66V24DIBv/LeqGTGT95TpTdRpQpp2RvhopzntP88EyGJf3mRXq9TQ5isHypbvKuimBwE2Ww3Un9vu+HBn8p3n4P3TDcOxOVeAGtALUdflGaHJbNhIQIDAQAB");
			return (RSAPublicKey) KeyFactory.getInstance("RSA").generatePublic(new X509EncodedKeySpec(bytes));
		} catch ( Exception e ) {
			throw new IllegalArgumentException(e);
		}
	}

	private static RSAPrivateKey privateKey() {
		try {
			byte[] bytes = Base64.getDecoder().decode("MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC1Y728xicK0vnkkpICQ8tVnwTMBylKg1IzjZQF1xqhlSSzxJhAxiuyFCatxgHpE1yqCUlf0RYJ4PXjLqe3lxMSxbpQBptkP/tCPW3ImbnQoDdQXAOi/efjHC2mHkQBsvHD8OIW3qs3eRfAOK7OO5aD1KGajF4TctNMtXL8H5Y/lh95ehI6sYdOP+Gl7EMbmlhQgU+gNvv0vPMFuCGlDc+/CDWWQoCcvU5guS/rpXbgMgG/8t6oZMZP3lOlN1GlCmnZG+GinOe0/zwTIYl/eZFer1NDmKwfKlu8q6KYHATZbDdSf2+74cGfynefg/dMNw7E5V4Aa0AtR1+UZocls2EhAgMBAAECggEAXWiYq97K+jr9LuT/xaTN0DDMkpjZfaK0sRGmeX91GmKofN6vnSOwGstfw7sk/rbW0EVqAKq2k63CUhSTj+p/ivpB4LYWTYDZTho+L8BiPPpUodBQmx3vzTeUlmgdk1ZoRAQHGcnfF/kG7xkBg/iRoR/dfK3uQEuwXl9OcGF/yQwRn83w6DFz//Q6NToUio4iAa2MyialSVdMrK49vjwwcMuP7JYp9kT4qhhJW7+AHoWAkcEJ71UjWvXZWARCEOKzw9G9kQ6kV/4OrBMaWvJbPrWPNz9eEcAZX15mdGuqYKlWFJlnua+4J5BZ7gREHhv85HzOJnal0xTFO+YOeA4GlQKBgQDxGX+duIB01NJLma0zIK6iRjeyDmkayy8GQK49e0OkVD4OWe59MlZ6t6SpWy+4vz3Kncjg2rg8UsQsSLi/SEBiLHYjyYEFsjneO/GkhLTdDy18vxZQzAmsUCpu5/1Bgl4oniIIgKT/ZEK++mNbEqHzcA3dvXggN+ZYHqjVmNyjnwKBgQDAmY4N4H+UZteTaYl/839CGzDzqJw43Ww6+bRsWRunj2G0TObRNFsrJHrhNa3G8Vu/eL8y5BDIVwpzHDf7NPewcDAYtxoY5N+ytIQRBSPLKEbkbkOtFFG3ZnAmt+EOqSOIoBXa7lNTlvAnSHR3R/iep20r5vKjHrE2TWZKqxvDPwKBgFMlMP5qZ1pjHpbVy4YrSi5KOuDb2WFVGsV0PuKTBNPB/ZijaPyiBHLTrCR/fuiegyfB3Em3A/xBqsd+2L+WoiV5IdDbp/QX7571WzMaVOk7V7uChqachuV2y/ttY8hYtjIZvrDh9ITixaXo4aTBuzohtZZ3xdqOjJBtGlp3GfgPAoGAN7XzJkZzAO1CnExhzpYTkH6nCUQTdEtwPBrwuoqH+k76NxorhgY7/N2/gZdyXeKA5IC75a+cvyaWSje2Zb6riujYsL1+GgdSQbH/paCz+tb6sqbGgrEm9gL2m+yCeCgqtCGCUOKxTbOSYfqOXdZ+rv3FEXbrZo3BOvDmjuCx1icCgYEAs4N8Y3R0tKmHRzUTUq9GVi1S8YOoPfOqL7bxXEfH2fgYt0zB8cJCjSzdpQ66+bY8gXSx9L32Js8eRgfpmxXtKdftCcdAO6fJfSTdSz/bZ9HrJkHquC/9lPTOVe8uSdBy9bkk2JF2Nk91azPCjyIdeWO4VMk5pzRe05z9O33U0SE=");
			return (RSAPrivateKey) KeyFactory.getInstance("RSA").generatePrivate(new PKCS8EncodedKeySpec(bytes));
		} catch ( Exception e ) {
			throw new IllegalArgumentException(e);
		}
	}
}
